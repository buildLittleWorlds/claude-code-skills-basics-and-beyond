<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Subagents â€” Skills: Basics and Beyond</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <header>
    <div class="container">
      <p class="site-label">Claude Code Skills</p>
      <h1><a href="index.html">Skills: Basics and Beyond</a></h1>
      <nav>
        <a href="index.html">Curriculum</a>
        <span class="phase-label">Phase 2: Integrated Advanced</span>
      </nav>
    </div>
  </header>

  <main class="container">

    <!-- SLOGAN BANNER -->
    <div class="slogan-banner">
      <span class="main-slogan">Build once, benefit every time.</span>
      <span class="subtext">A hands-on curriculum for building skills, hooks, agents, and workflows in Claude Code.</span>
    </div>

    <!-- PAGE TITLE -->
    <h1 class="page-title">Custom Subagents &mdash; Specialized AI Workers</h1>

    <!-- COURSE METADATA -->
    <div class="course-meta">
      <span class="meta-pill">Course <strong>8</strong> of 12</span>
      <span class="meta-pill"><strong>Advanced</strong></span>
      <span class="meta-pill">40 min</span>
    </div>

    <!-- LEAD PARAGRAPH -->
    <p class="lead">In Course 5, you learned that a skill can run in a forked context using <code>context: fork</code> and <code>agent: Explore</code> &mdash; your first brush with subagents. Now you&rsquo;re going to build them from scratch. A <strong>subagent</strong> is a standalone AI worker with its own system prompt, tool access, context window, and optionally its own model, permissions, hooks, and persistent memory. In this course, you&rsquo;ll create a fast <strong>test-runner</strong> on Haiku with restricted tools, a read-only <strong>security-reviewer</strong> on Sonnet with cross-session memory, and a <strong>security-patterns</strong> skill that the reviewer preloads for domain knowledge. You&rsquo;ll also learn to monitor subagents with tmux split panes from Course 7&frac12;.</p>

    <!-- PREREQUISITES -->
    <div class="callout info">
      <p><strong>Prerequisites:</strong></p>
      <ul>
        <li>Completed <strong>Courses 1&ndash;7</strong> (skills fundamentals, hooks, the full build-up)</li>
        <li>Completed <strong>Course 7&frac12;: Your Terminal Workspace</strong> (tmux prerequisite &mdash; split panes, detached sessions, send-keys, capture-pane)</li>
        <li>Comfortable with <code>Ctrl+J</code> as your tmux prefix key</li>
        <li>Claude Code installed and working (<code>claude</code> command available)</li>
      </ul>
    </div>

    <!-- CONCEPTS -->
    <h2>Concepts</h2>

    <h3>What Are Subagents?</h3>

    <p>In Course 5, you learned that a skill can run in a forked context using <code>context: fork</code> and <code>agent: Explore</code>. That was your first brush with subagents &mdash; isolated AI workers that run in their own context window.</p>

    <p>Now you&rsquo;re going to build them from scratch.</p>

    <p>A <strong>subagent</strong> is a standalone AI assistant with:</p>

    <ul>
      <li>Its own <strong>system prompt</strong> (the markdown body of the agent file)</li>
      <li>Its own <strong>tool access</strong> (which tools it can use)</li>
      <li>Its own <strong>context window</strong> (isolated from your main conversation)</li>
      <li>Optionally, its own <strong>model</strong>, <strong>permissions</strong>, <strong>hooks</strong>, <strong>skills</strong>, and <strong>memory</strong></li>
    </ul>

    <p>When Claude encounters a task that matches a subagent&rsquo;s description, it delegates to that subagent. The subagent works independently and returns results to the main conversation. Think of it as a specialist you can call on &mdash; a security expert, a test runner, a documentation writer &mdash; each with exactly the tools and knowledge they need.</p>

    <p><strong>When do you need a subagent instead of a skill?</strong> Not always. Skills are simpler, faster, and cheaper. Subagents earn their keep when the context window is filling up, when you need tool restrictions per phase, when intermediate output is too verbose for the main session, or when you need independent critique free from self-critic bias.</p>

    <h3>Built-in vs Custom Subagents</h3>

    <p>Claude Code comes with several built-in subagents:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Subagent</th>
          <th>Model</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Explore</strong></td>
          <td>Haiku (fast)</td>
          <td>Read-only codebase search and analysis</td>
        </tr>
        <tr>
          <td><strong>Plan</strong></td>
          <td>Inherits</td>
          <td>Research agent for plan mode</td>
        </tr>
        <tr>
          <td><strong>general-purpose</strong></td>
          <td>Inherits</td>
          <td>Complex multi-step tasks requiring all tools</td>
        </tr>
        <tr>
          <td><strong>Bash</strong></td>
          <td>Inherits</td>
          <td>Terminal commands in a separate context</td>
        </tr>
      </tbody>
    </table>

    <p>You&rsquo;ve already used Explore (Course 5&rsquo;s <code>agent: Explore</code> field). These built-in subagents handle common patterns, but real projects need specialized workers. That&rsquo;s what custom subagents are for.</p>

    <h3>Where Subagent Files Live</h3>

    <p>Like skills, subagents live at different levels depending on scope:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Location</th>
          <th>Scope</th>
          <th>Priority</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>--agents</code> CLI flag</td>
          <td>Current session only</td>
          <td>1 (highest)</td>
        </tr>
        <tr>
          <td><code>.claude/agents/</code></td>
          <td>Current project</td>
          <td>2</td>
        </tr>
        <tr>
          <td><code>~/.claude/agents/</code></td>
          <td>All your projects</td>
          <td>3</td>
        </tr>
        <tr>
          <td>Plugin <code>agents/</code> directory</td>
          <td>Where plugin is enabled</td>
          <td>4 (lowest)</td>
        </tr>
      </tbody>
    </table>

    <p>When multiple subagents share the same name, the higher-priority location wins.</p>

    <p><strong>Project subagents</strong> (<code>.claude/agents/</code>) are ideal for project-specific workflows. Check them into version control so your team benefits. <strong>User subagents</strong> (<code>~/.claude/agents/</code>) are personal &mdash; available everywhere you use Claude Code.</p>

    <!-- DIVIDER between concept groups -->
    <div class="divider"></div>

    <h3>The Subagent File Format</h3>

    <p>Subagent files are Markdown with YAML frontmatter &mdash; just like skills, but with different fields:</p>

    <div class="yaml-block"><span class="yaml-delimiter">---</span>
<span class="yaml-key">name:</span> <span class="yaml-value">my-agent</span>
<span class="yaml-key">description:</span> <span class="yaml-value">When Claude should delegate to this agent</span>
<span class="yaml-key">tools:</span> <span class="yaml-value">Read, Grep, Glob</span>
<span class="yaml-key">model:</span> <span class="yaml-value">haiku</span>
<span class="yaml-delimiter">---</span></div>

    <pre>You are a specialist. When invoked, do the following:
1. Step one
2. Step two
3. Return your findings</pre>

    <p>The frontmatter defines configuration. The body becomes the <strong>system prompt</strong> &mdash; the only instructions the subagent receives (it doesn&rsquo;t get the full Claude Code system prompt, just yours plus basic environment info like the working directory).</p>

    <h3>Configuration Fields</h3>

    <p>Here&rsquo;s the full set of frontmatter fields:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Field</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>name</code></td>
          <td>Yes</td>
          <td>Unique identifier, lowercase letters and hyphens</td>
        </tr>
        <tr>
          <td><code>description</code></td>
          <td>Yes</td>
          <td>When Claude should delegate to this subagent</td>
        </tr>
        <tr>
          <td><code>tools</code></td>
          <td>No</td>
          <td>Tools the subagent can use (inherits all if omitted)</td>
        </tr>
        <tr>
          <td><code>disallowedTools</code></td>
          <td>No</td>
          <td>Tools to deny, removed from inherited or specified list</td>
        </tr>
        <tr>
          <td><code>model</code></td>
          <td>No</td>
          <td><code>sonnet</code>, <code>opus</code>, <code>haiku</code>, or <code>inherit</code> (default: <code>inherit</code>)</td>
        </tr>
        <tr>
          <td><code>permissionMode</code></td>
          <td>No</td>
          <td><code>default</code>, <code>acceptEdits</code>, <code>delegate</code>, <code>dontAsk</code>, <code>bypassPermissions</code>, <code>plan</code></td>
        </tr>
        <tr>
          <td><code>maxTurns</code></td>
          <td>No</td>
          <td>Maximum agentic turns before the subagent stops</td>
        </tr>
        <tr>
          <td><code>skills</code></td>
          <td>No</td>
          <td>Skills to preload into the subagent&rsquo;s context</td>
        </tr>
        <tr>
          <td><code>mcpServers</code></td>
          <td>No</td>
          <td>MCP servers available to this subagent</td>
        </tr>
        <tr>
          <td><code>hooks</code></td>
          <td>No</td>
          <td>Lifecycle hooks scoped to this subagent</td>
        </tr>
        <tr>
          <td><code>memory</code></td>
          <td>No</td>
          <td>Persistent memory scope: <code>user</code>, <code>project</code>, or <code>local</code></td>
        </tr>
      </tbody>
    </table>

    <p>Let&rsquo;s walk through the most important fields.</p>

    <h3>Controlling Tool Access</h3>

    <p>The <code>tools</code> field is an allowlist &mdash; only listed tools are available:</p>

    <div class="yaml-block"><span class="yaml-key">tools:</span> <span class="yaml-value">Read, Grep, Glob</span></div>

    <p>This creates a read-only agent. Compare with the <code>disallowedTools</code> field, which is a denylist:</p>

    <div class="yaml-block"><span class="yaml-key">disallowedTools:</span> <span class="yaml-value">Write, Edit</span></div>

    <p>This inherits all tools <em>except</em> Write and Edit. Both achieve similar results, but the allowlist (<code>tools</code>) is more explicit and safer &mdash; if new tools are added to Claude Code, an allowlist agent won&rsquo;t accidentally gain access.</p>

    <p>For fine-grained control, use tool patterns:</p>

    <div class="yaml-block"><span class="yaml-key">tools:</span> <span class="yaml-value">Bash(git *), Read, Grep, Glob</span></div>

    <p>This allows Bash but only for <code>git</code> commands. The <code>Bash(pattern)</code> syntax restricts which commands the subagent can run.</p>

    <h3>Choosing a Model</h3>

    <p>The <code>model</code> field controls cost and speed:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Model</th>
          <th>Tradeoff</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>haiku</code></td>
          <td>Fastest, cheapest &mdash; good for routine tasks like running tests, simple searches</td>
        </tr>
        <tr>
          <td><code>sonnet</code></td>
          <td>Balanced &mdash; good for analysis, code review, moderate complexity</td>
        </tr>
        <tr>
          <td><code>opus</code></td>
          <td>Most capable &mdash; good for complex reasoning, architecture decisions</td>
        </tr>
        <tr>
          <td><code>inherit</code></td>
          <td>Uses the same model as the main conversation (default)</td>
        </tr>
      </tbody>
    </table>

    <p>Use haiku for high-volume, well-scoped tasks. Use sonnet or opus when the subagent needs deeper reasoning.</p>

    <h3>Preloading Skills</h3>

    <p>The <code>skills</code> field injects skill content into the subagent&rsquo;s context at startup:</p>

    <div class="yaml-block"><span class="yaml-key">skills:</span>
  <span class="yaml-value">- security-patterns</span>
  <span class="yaml-value">- error-handling-patterns</span></div>

    <p>This is different from skills in the main conversation. The full content of each listed skill is injected directly &mdash; the subagent doesn&rsquo;t discover and load them on demand. It has the knowledge from the start.</p>

    <p><strong>Important</strong>: Subagents don&rsquo;t inherit skills from the parent conversation. You must list them explicitly.</p>

    <h3>Persistent Memory</h3>

    <p>The <code>memory</code> field gives the subagent a directory that persists across conversations:</p>

    <div class="yaml-block"><span class="yaml-key">memory:</span> <span class="yaml-value">project</span></div>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Scope</th>
          <th>Location</th>
          <th>Use when</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>user</code></td>
          <td><code>~/.claude/agent-memory/&lt;name&gt;/</code></td>
          <td>Knowledge applies across all projects</td>
        </tr>
        <tr>
          <td><code>project</code></td>
          <td><code>.claude/agent-memory/&lt;name&gt;/</code></td>
          <td>Knowledge is project-specific, shareable via VCS</td>
        </tr>
        <tr>
          <td><code>local</code></td>
          <td><code>.claude/agent-memory-local/&lt;name&gt;/</code></td>
          <td>Project-specific, not checked into VCS</td>
        </tr>
      </tbody>
    </table>

    <p>When memory is enabled:</p>

    <ul>
      <li>The subagent&rsquo;s system prompt includes instructions for reading and writing to the memory directory</li>
      <li>The first 200 lines of <code>MEMORY.md</code> in that directory are included in the prompt</li>
      <li>Read, Write, and Edit tools are automatically enabled so the subagent can manage its memory</li>
    </ul>

    <p>This means a security reviewer can accumulate project-specific patterns over time &mdash; each invocation gets smarter because it builds on previous findings.</p>

    <!-- DIVIDER between concept groups -->
    <div class="divider"></div>

    <h3>Hooks in Subagent Frontmatter</h3>

    <p>Subagents can define their own lifecycle hooks:</p>

    <div class="yaml-block"><span class="yaml-key">hooks:</span>
  <span class="yaml-key">PreToolUse:</span>
    <span class="yaml-value">- matcher: "Bash"</span>
      <span class="yaml-key">hooks:</span>
        <span class="yaml-value">- type: command</span>
          <span class="yaml-value">command: "./scripts/validate-command.sh"</span>
  <span class="yaml-key">PostToolUse:</span>
    <span class="yaml-value">- matcher: "Edit|Write"</span>
      <span class="yaml-key">hooks:</span>
        <span class="yaml-value">- type: command</span>
          <span class="yaml-value">command: "./scripts/run-linter.sh"</span></div>

    <p>These hooks only run while that specific subagent is active. Common events:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Event</th>
          <th>Matcher input</th>
          <th>When it fires</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>PreToolUse</code></td>
          <td>Tool name</td>
          <td>Before the subagent uses a tool</td>
        </tr>
        <tr>
          <td><code>PostToolUse</code></td>
          <td>Tool name</td>
          <td>After the subagent uses a tool</td>
        </tr>
        <tr>
          <td><code>Stop</code></td>
          <td>(none)</td>
          <td>When the subagent finishes</td>
        </tr>
      </tbody>
    </table>

    <p>You can also configure hooks in <code>settings.json</code> that respond to subagent lifecycle events in the main session:</p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Event</th>
          <th>Matcher input</th>
          <th>When it fires</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>SubagentStart</code></td>
          <td>Agent type name</td>
          <td>When a subagent begins execution</td>
        </tr>
        <tr>
          <td><code>SubagentStop</code></td>
          <td>Agent type name</td>
          <td>When a subagent completes</td>
        </tr>
      </tbody>
    </table>

    <h3>Foreground vs Background Execution</h3>

    <p>Subagents can run two ways:</p>

    <ul>
      <li><strong>Foreground</strong> (blocking): The main conversation waits for the subagent to finish. Permission prompts and clarifying questions pass through to you.</li>
      <li><strong>Background</strong> (concurrent): The subagent runs while you continue working. Permissions are pre-approved upfront; if the subagent needs to ask a question, that call fails but work continues.</li>
    </ul>

    <p>Claude decides based on the task, or you can ask: &ldquo;run this in the background.&rdquo; You can also press <code>Ctrl+B</code> to background a running task.</p>

    <p>If a background subagent fails due to missing permissions, you can resume it in the foreground to retry with interactive prompts.</p>

    <h3>The <code>/agents</code> Command</h3>

    <p>Run <code>/agents</code> in Claude Code to manage subagents interactively:</p>

    <ul>
      <li>View all available subagents (built-in, user, project, plugin)</li>
      <li>Create new subagents with guided setup or Claude generation</li>
      <li>Edit existing subagent configuration</li>
      <li>Delete custom subagents</li>
      <li>See which subagents are active when duplicates exist</li>
    </ul>

    <p>This is the recommended way to manage subagents day-to-day.</p>

    <!-- DIVIDER between concept groups -->
    <div class="divider"></div>

    <h3>Monitoring Subagents with tmux</h3>

    <p>Here&rsquo;s where your tmux skills from Course 7&frac12; come in.</p>

    <p><strong>The problem</strong>: When a subagent runs in the background or in a forked context, you can&rsquo;t see what it&rsquo;s doing from your main session. You see the final result, but not the process &mdash; which tools it called, what files it read, whether it hit a permissions issue.</p>

    <p><strong>The pattern</strong>: Use tmux split panes to watch a subagent work in real time.</p>

    <p><strong>The Headless Agent Monitoring Setup</strong></p>

    <p>This draws directly from the tmux-claude tutorial&rsquo;s Lesson 9 (headless Claude sessions). The idea is to run Claude in a detached tmux session and monitor from another pane:</p>

    <ol>
      <li><strong>Create a monitoring session</strong> (or use your existing session):
        <div class="terminal-block"><span class="prompt">$ </span>tmux new-session -d -s agent-monitor</div>
      </li>
      <li><strong>Set up split panes</strong> &mdash; left pane for your main Claude session, right pane for tailing the agent&rsquo;s work: <code>Ctrl+J %</code></li>
      <li><strong>In the right pane, peek at agent progress</strong>:
        <div class="terminal-block"><span class="prompt">$ </span>tmux capture-pane -t agent-session -p | tail -20</div>
      </li>
      <li>Or use <code>watch</code> for continuous monitoring:
        <div class="terminal-block"><span class="prompt">$ </span>watch -n 2 'tmux capture-pane -t agent-session -p | tail -15'</div>
      </li>
    </ol>

    <p><strong>When to Use tmux Monitoring vs In-Process Execution</strong></p>

    <table class="tool-table">
      <thead>
        <tr>
          <th>Use tmux monitoring when&hellip;</th>
          <th>Use in-process execution when&hellip;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Debugging tool restrictions</td>
          <td>The subagent is working correctly</td>
        </tr>
        <tr>
          <td>Watching the agent&rsquo;s raw output</td>
          <td>You only need the final result</td>
        </tr>
        <tr>
          <td>Running multiple agents in parallel</td>
          <td>The task is quick and focused</td>
        </tr>
        <tr>
          <td>Developing/testing a new subagent</td>
          <td>Using a well-tested subagent</td>
        </tr>
      </tbody>
    </table>

    <p><strong>Important</strong>: Tmux monitoring is a <strong>development/debugging workflow</strong>. Once your subagent works correctly, you typically run it in-process and just review the returned results. The split-pane approach is for when you need visibility into the agent&rsquo;s process, not its output.</p>

    <p>Refer to the tmux quick-reference from Course 7&frac12; for the exact commands.</p>

    <!-- KEY REFERENCES -->
    <div class="callout insight">
      <p><strong>Key References:</strong></p>
      <ul>
        <li><strong>Subagents docs</strong>: Full configuration reference (fields, tools, models, hooks, memory)</li>
        <li><strong>tmux-claude tutorial Lesson 9</strong>: Headless Claude sessions (the detached-session pattern)</li>
        <li><strong>Course 7&frac12; tmux-quickref.md</strong>: Quick reference for tmux commands used in this course</li>
        <li><strong>Choosing the Right Mode</strong>: <code>courses/references/choosing-the-right-mode.md</code> &mdash; decision framework for skills vs subagents vs agent teams</li>
      </ul>
    </div>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- WHAT YOU'RE BUILDING -->
    <h2>What You&rsquo;re Building</h2>

    <p>Two custom subagents and a supporting skill:</p>

    <ol>
      <li><strong><code>test-runner</code></strong> &mdash; A fast, cheap agent using Haiku that runs your test suite and reports results. Demonstrates model selection and tool restrictions.</li>
      <li><strong><code>security-reviewer</code></strong> &mdash; A read-only agent with persistent memory that reviews code for security issues. Demonstrates memory, skill preloading, and the read-only pattern.</li>
      <li><strong><code>security-patterns</code></strong> skill &mdash; Preloaded into the security-reviewer, giving it OWASP Top 10 knowledge without needing to discover it at runtime.</li>
    </ol>

    <div class="callout info">
      <p>Together, these demonstrate the core subagent patterns:</p>
      <table class="tool-table">
        <thead>
          <tr>
            <th>Component</th>
            <th>Pattern demonstrated</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>test-runner</code> agent</td>
            <td>Cost optimization (Haiku), tool restrictions (Bash, Read, Grep only)</td>
          </tr>
          <tr>
            <td><code>security-reviewer</code> agent</td>
            <td>Read-only tools, persistent memory, skill preloading</td>
          </tr>
          <tr>
            <td><code>security-patterns</code> skill</td>
            <td>Domain knowledge injection via preloaded skills</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- WALKTHROUGH -->
    <h2>Walkthrough</h2>

    <div class="step-card">
      <span class="step-number">1</span>
      <span class="step-title">Create the security-patterns Skill</span>
      <div class="step-content">
        <p>The security-reviewer subagent needs domain knowledge about common vulnerabilities. Instead of putting all that content in the agent&rsquo;s system prompt (which would be too long), you&rsquo;ll create a skill that the agent preloads.</p>

        <p>Create the skill directory:</p>

        <div class="terminal-block"><span class="prompt">$ </span>mkdir -p ~/.claude/skills/security-patterns/references</div>

        <p>Create <code>~/.claude/skills/security-patterns/SKILL.md</code>:</p>

        <div class="skill-file">
          <div class="skill-file-header">~/.claude/skills/security-patterns/SKILL.md</div>
          <pre>---
name: security-patterns
description: Reference material for common security vulnerabilities and secure coding patterns. Use when reviewing code for security issues or implementing security-sensitive features.
---

# Security Patterns Reference

When reviewing code for security issues, check for the following categories.

## Injection Flaws
- **SQL Injection**: Look for string concatenation in SQL queries. Require parameterized queries or prepared statements.
- **Command Injection**: Look for user input passed to shell commands, `exec()`, `eval()`, or `system()` calls. Require input sanitization and allowlists.
- **XSS (Cross-Site Scripting)**: Look for unsanitized user input rendered in HTML. Require output encoding and Content Security Policy headers.

## Authentication and Session Management
- Hardcoded credentials, API keys, or secrets in source code
- Missing or weak password hashing (look for MD5, SHA1 without salt)
- Session tokens in URLs or logs
- Missing session expiration or rotation after login

## Sensitive Data Exposure
- Secrets in environment variables without `.env` in `.gitignore`
- API keys or tokens committed to version control
- Logging of sensitive data (passwords, tokens, PII)
- Missing encryption for data in transit (HTTP instead of HTTPS)

## Access Control
- Missing authorization checks on endpoints or functions
- Direct object references without ownership validation
- Privilege escalation through parameter manipulation
- Missing rate limiting on sensitive operations

## Security Misconfiguration
- Debug mode enabled in production
- Default credentials left unchanged
- Overly permissive CORS settings
- Missing security headers (HSTS, X-Frame-Options, CSP)

## Input Validation
- Missing or client-side-only validation
- Path traversal vulnerabilities (`../` in file paths)
- Unrestricted file upload (type, size, content)
- Integer overflow or type confusion

For detailed descriptions, see `references/owasp-top-10.md`.</pre>
        </div>

        <p>Create the OWASP reference at <code>~/.claude/skills/security-patterns/references/owasp-top-10.md</code>:</p>

        <div class="skill-file">
          <div class="skill-file-header">~/.claude/skills/security-patterns/references/owasp-top-10.md</div>
          <pre># OWASP Top 10 Quick Reference

## A01: Broken Access Control
- Violation of least privilege or deny-by-default
- Bypassing access checks by modifying URLs, API requests, or internal state
- Accessing another user's records by providing their identifier (IDOR)
- Missing access control for POST, PUT, DELETE
- **Check for**: Authorization middleware on every route, ownership validation on data access

## A02: Cryptographic Failures
- Data transmitted in clear text (HTTP, SMTP, FTP)
- Use of old or weak cryptographic algorithms (MD5, SHA1, DES)
- Default or missing encryption keys
- **Check for**: TLS everywhere, strong hashing (bcrypt, argon2), proper key management

## A03: Injection
- User-supplied data not validated, filtered, or sanitized
- Dynamic queries without parameterization
- Hostile data used in ORM search parameters
- **Check for**: Parameterized queries, input validation, ORM safe methods

## A04: Insecure Design
- Missing threat modeling
- No rate limiting on high-value transactions
- Missing input validation at the business logic level
- **Check for**: Design-level security controls, abuse case testing

## A05: Security Misconfiguration
- Missing security hardening across the application stack
- Unnecessary features enabled (ports, services, pages, accounts)
- Default accounts and passwords unchanged
- Error handling reveals stack traces or sensitive information
- **Check for**: Hardened defaults, minimal attack surface, no stack traces in production

## A06: Vulnerable and Outdated Components
- Dependencies with known CVEs
- Unmaintained libraries
- **Check for**: `npm audit`, `pip-audit`, dependabot alerts, lock file freshness

## A07: Identification and Authentication Failures
- Permits brute force or credential stuffing
- Uses default, weak, or well-known passwords
- Missing or ineffective multi-factor authentication
- **Check for**: Rate limiting on auth endpoints, strong password policies, MFA support

## A08: Software and Data Integrity Failures
- Dependencies from untrusted sources without integrity verification
- CI/CD pipelines without integrity checks
- Auto-update without signature verification
- **Check for**: Lock files with integrity hashes, signed releases, CI/CD access controls

## A09: Security Logging and Monitoring Failures
- Auditable events not logged (logins, failed logins, high-value transactions)
- Logs not monitored for suspicious activity
- Logs only stored locally
- **Check for**: Centralized logging, alerting on auth failures, audit trails

## A10: Server-Side Request Forgery (SSRF)
- Fetching remote resources without validating user-supplied URLs
- No allowlist for destination addresses
- **Check for**: URL validation, allowlists for external requests, blocking internal network access</pre>
        </div>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">2</span>
      <span class="step-title">Create the test-runner Subagent</span>
      <div class="step-content">
        <p>This agent uses Haiku for speed and cost efficiency. It runs tests, captures output, and reports results.</p>

        <p>Create <code>~/.claude/agents/test-runner.md</code>:</p>

        <div class="skill-file">
          <div class="skill-file-header">~/.claude/agents/test-runner.md</div>
          <pre>---
name: test-runner
description: Fast test runner that executes test suites and reports results. Use when the user says "run tests", "run the test suite", "check if tests pass", or "fix failing tests". Use proactively after code changes.
tools: Bash, Read, Grep
model: haiku
---

You are a fast, focused test runner. Your job is to execute test suites and report results clearly.

When invoked:

1. **Detect the test framework** by looking for:
   - `package.json` with test scripts -> `npm test` or `npx jest` or `npx vitest`
   - `pytest.ini`, `pyproject.toml`, or `tests/` directory -> `pytest`
   - `Cargo.toml` -> `cargo test`
   - `go.mod` -> `go test ./...`
   - `Makefile` with a test target -> `make test`

2. **Run the test suite** using the detected framework.

3. **Report results** in this format:

   ### Test Results
   - **Status**: PASS / FAIL
   - **Total**: N tests
   - **Passed**: N
   - **Failed**: N
   - **Skipped**: N

   If any tests failed:
   ### Failures
   For each failure:
   - **Test name**: `test_name_here`
   - **File**: `path/to/test/file.py:line`
   - **Error**: Brief description of what went wrong
   - **Relevant code**: The failing assertion or error

4. **Do not fix code**. Your job is to report, not repair. If asked to fix failures, explain what went wrong but defer the actual fix to the main conversation.

## Rules
- Run the full suite unless the user specifies a subset
- If no test framework is detected, say so and ask what command to use
- Keep output concise -- summarize, don't dump raw terminal output
- If tests take longer than 60 seconds, note the runtime</pre>
        </div>

        <p>Key points:</p>

        <ul>
          <li><code>model: haiku</code> &mdash; fastest, cheapest model for routine tasks</li>
          <li><code>tools: Bash, Read, Grep</code> &mdash; only what&rsquo;s needed; no Edit or Write (the agent reports, not repairs)</li>
          <li>The system prompt defines a structured output format for consistent results</li>
        </ul>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">3</span>
      <span class="step-title">Create the security-reviewer Subagent</span>
      <div class="step-content">
        <p>This agent is read-only, preloads the security-patterns skill, and uses persistent project-level memory to accumulate knowledge about the codebase&rsquo;s security profile over time.</p>

        <p>Create <code>~/.claude/agents/security-reviewer.md</code>:</p>

        <div class="skill-file">
          <div class="skill-file-header">~/.claude/agents/security-reviewer.md</div>
          <pre>---
name: security-reviewer
description: Reviews code for security vulnerabilities and insecure patterns. Use when the user says "review for security", "security audit", "check for vulnerabilities", or "is this code secure". Use proactively when reviewing authentication, authorization, or data handling code.
tools: Read, Grep, Glob
model: sonnet
memory: project
skills:
  - security-patterns
---

You are a security-focused code reviewer. You have read-only access to the codebase. Your job is to identify vulnerabilities, insecure patterns, and security risks.

When invoked:

1. **Check your memory** for previously identified patterns in this project. Review your MEMORY.md to see if you've noted recurring issues, security-sensitive files, or architectural patterns.

2. **Identify scope**. If a specific file or directory was mentioned, focus there. Otherwise, prioritize:
   - Authentication and authorization code
   - API endpoints and route handlers
   - Database queries and data access layers
   - Configuration files and environment handling
   - Input validation and output encoding
   - Dependency manifests (package.json, requirements.txt, etc.)

3. **Scan for vulnerabilities** using the security-patterns skill as your checklist. For each issue found, report:

   ### Finding: [Short Title]
   - **Severity**: Critical / High / Medium / Low
   - **Category**: [OWASP category, e.g., A03: Injection]
   - **File**: `path/to/file.ext:line`
   - **Issue**: What's wrong and why it matters
   - **Evidence**: The specific code that's vulnerable
   - **Recommendation**: How to fix it, with a code example if helpful

4. **Summarize** at the end:
   - Total findings by severity
   - Top priority items to fix first
   - Overall security posture assessment (1-2 sentences)

5. **Update your memory** with what you learned:
   - Security-sensitive files and directories in this project
   - Recurring patterns (good or bad) you've observed
   - Framework-specific security notes
   - Any custom security middleware or utilities the project uses

## Rules
- You are read-only. Never suggest running commands that modify code.
- Be specific: "Line 42 of auth.ts concatenates user input into a SQL query" not "there might be SQL injection somewhere".
- Don't report theoretical vulnerabilities -- only flag what you can see in the code.
- If you find no issues, say so. Don't invent problems.
- Always check your memory first to see if you've reviewed this area before.</pre>
        </div>

        <p>Key points:</p>

        <ul>
          <li><code>model: sonnet</code> &mdash; more capable model for deeper security analysis</li>
          <li><code>tools: Read, Grep, Glob</code> &mdash; strictly read-only; no Bash, Edit, or Write</li>
          <li><code>memory: project</code> &mdash; builds up knowledge at <code>.claude/agent-memory/security-reviewer/</code></li>
          <li><code>skills: [security-patterns]</code> &mdash; OWASP checklist injected into context at startup</li>
        </ul>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">4</span>
      <span class="step-title">Verify the File Structure</span>
      <div class="step-content">
        <p>Confirm everything is in the right place:</p>

        <div class="terminal-block"><span class="comment"># Check the agents</span>
<span class="prompt">$ </span>ls -la ~/.claude/agents/test-runner.md
<span class="prompt">$ </span>ls -la ~/.claude/agents/security-reviewer.md

<span class="comment"># Check the skill</span>
<span class="prompt">$ </span>ls -la ~/.claude/skills/security-patterns/SKILL.md
<span class="prompt">$ </span>ls -la ~/.claude/skills/security-patterns/references/owasp-top-10.md</div>

        <p>You should see all four files. If <code>~/.claude/agents/</code> doesn&rsquo;t exist, create it:</p>

        <div class="terminal-block"><span class="prompt">$ </span>mkdir -p ~/.claude/agents</div>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">5</span>
      <span class="step-title">Verify Agent Visibility</span>
      <div class="step-content">
        <p>Open a new Claude Code session (subagents are loaded at session start) and run:</p>

        <div class="prompt-box-dark">/agents</div>

        <p>You should see <code>test-runner</code> and <code>security-reviewer</code> listed alongside the built-in subagents (Explore, Plan, general-purpose, etc.).</p>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">6</span>
      <span class="step-title">Test the test-runner Agent</span>
      <div class="step-content">
        <p>In any project that has tests, ask Claude:</p>

        <div class="prompt-box-dark">Run the test suite</div>

        <p>Claude should recognize the test-runner agent from its description and delegate to it. Watch for:</p>

        <ul>
          <li>Claude says it&rsquo;s delegating to the test-runner subagent</li>
          <li>The agent uses <strong>Haiku</strong> (you&rsquo;ll see this in the subagent header)</li>
          <li>It only uses <strong>Bash, Read, and Grep</strong> (no Edit or Write)</li>
          <li>Results come back in the structured format from the agent&rsquo;s prompt</li>
        </ul>

        <p>You can also invoke it explicitly:</p>

        <div class="prompt-box-dark">Use the test-runner subagent to check if all tests pass</div>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">7</span>
      <span class="step-title">Test the security-reviewer Agent</span>
      <div class="step-content">
        <p>Ask Claude to review a file:</p>

        <div class="prompt-box-dark">Review src/auth.ts for security issues</div>

        <p>Or for a broader scan:</p>

        <div class="prompt-box-dark">Do a security audit of this project</div>

        <p>Watch for:</p>

        <ul>
          <li>Claude delegates to the security-reviewer subagent</li>
          <li>The agent uses <strong>Sonnet</strong> (more capable model for deeper analysis)</li>
          <li>It only uses <strong>Read, Grep, and Glob</strong> (read-only &mdash; no Bash, Edit, or Write)</li>
          <li>The security-patterns skill content is available immediately (the agent doesn&rsquo;t need to discover it)</li>
          <li>Findings follow the structured format with severity, category, and OWASP references</li>
        </ul>

        <p>Run it a second time. The agent should check its memory for patterns from the first invocation. Over multiple runs, it builds up a project-specific security knowledge base.</p>
      </div>
    </div>

    <div class="step-card">
      <span class="step-number">8</span>
      <span class="step-title">Monitor a Subagent with tmux</span>
      <div class="step-content">
        <p>This is the development/debugging workflow from the concepts section.</p>

        <ol>
          <li><strong>Start a tmux session</strong> (or use your existing one):
            <div class="terminal-block"><span class="prompt">$ </span>tmux new -s dev</div>
          </li>
          <li><strong>Split vertically</strong> &mdash; left pane for your main Claude session, right pane for monitoring: <code>Ctrl+J %</code></li>
          <li><strong>In the left pane</strong>, start Claude:
            <div class="terminal-block"><span class="prompt">$ </span>claude</div>
          </li>
          <li><strong>In the left pane</strong>, trigger the security-reviewer:
            <div class="prompt-box-dark">Review this project for security vulnerabilities</div>
          </li>
          <li><strong>In the right pane</strong> (<code>Ctrl+J &rarr;</code>), start a headless Claude in a detached session:
            <div class="terminal-block"><span class="prompt">$ </span>tmux new-session -d -s security-review "cd $(pwd) &amp;&amp; claude 'Use the security-reviewer to audit this project'"</div>
          </li>
          <li><strong>Peek at the headless agent&rsquo;s progress</strong> from the right pane:
            <div class="terminal-block"><span class="prompt">$ </span>tmux capture-pane -t security-review -p | tail -20</div>
          </li>
          <li>Or <strong>attach to watch live</strong>:
            <div class="terminal-block"><span class="prompt">$ </span>tmux attach -t security-review</div>
            <p>(Detach with <code>Ctrl+J d</code> when you&rsquo;ve seen enough)</p>
          </li>
          <li><strong>Clean up</strong> the headless session when done:
            <div class="terminal-block"><span class="prompt">$ </span>tmux kill-session -t security-review</div>
          </li>
        </ol>

        <p>This pattern is essential when you&rsquo;re developing a new subagent and need to see exactly what tools it&rsquo;s calling, what files it&rsquo;s reading, and where it gets stuck.</p>
      </div>
    </div>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- EXERCISES -->
    <h2>Exercises</h2>

    <ol>
      <li>
        <p><strong>Create and test both agents</strong></p>
        <p>Install the test-runner and security-reviewer agents as described in the walkthrough. Run the test-runner against a project with tests and verify it uses Haiku and restricted tools. Run the security-reviewer and verify it uses Sonnet, read-only tools, and the preloaded security-patterns skill. Confirm that the security-reviewer&rsquo;s memory accumulates across invocations.</p>
      </li>
      <li>
        <p><strong>Test the security-reviewer&rsquo;s memory</strong></p>
        <p>Run the security-reviewer on the same project twice. After the first run, check that <code>MEMORY.md</code> was created in <code>.claude/agent-memory/security-reviewer/</code>. Read it. On the second run, verify the agent references its prior findings. Add a deliberately insecure pattern to a file (e.g., string concatenation in a SQL query) and run the reviewer again &mdash; does it catch it and relate it to prior findings?</p>
      </li>
      <li>
        <p><strong>Monitor a subagent with tmux</strong></p>
        <p>Set up the split-pane layout from Step 8. In the left pane, start Claude and trigger the security-reviewer agent. In the right pane, launch a headless Claude session running the same review, then use <code>tmux capture-pane</code> to peek at its progress. Verify you can see which tools the agent is calling and what files it&rsquo;s reading. Compare the experience of watching the agent work in real time vs just seeing the final output.</p>
      </li>
      <li>
        <p><strong>Build your own subagent</strong></p>
        <p>Create a custom subagent for a task you do frequently. Some ideas:</p>
        <ul>
          <li>A <strong>doc-writer</strong> (tools: Read, Grep, Glob, Write; model: sonnet) that generates or updates documentation</li>
          <li>A <strong>dependency-checker</strong> (tools: Bash, Read; model: haiku) that audits outdated packages</li>
          <li>A <strong>log-analyzer</strong> (tools: Read, Grep, Glob; model: haiku) that scans log files for errors and patterns</li>
        </ul>
        <p>Give it a clear description, appropriate tool restrictions, and test that Claude delegates to it correctly.</p>
      </li>
    </ol>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- VERIFICATION CHECKLIST -->
    <h2>Verification Checklist</h2>

    <ul class="checklist">
      <li><code>~/.claude/agents/test-runner.md</code> exists with valid YAML frontmatter</li>
      <li><code>~/.claude/agents/security-reviewer.md</code> exists with valid YAML frontmatter</li>
      <li><code>~/.claude/skills/security-patterns/SKILL.md</code> exists with the vulnerability checklist</li>
      <li><code>~/.claude/skills/security-patterns/references/owasp-top-10.md</code> exists</li>
      <li>Running <code>/agents</code> shows both custom agents alongside the built-ins</li>
      <li>The test-runner uses Haiku and is restricted to Bash, Read, Grep</li>
      <li>The security-reviewer uses Sonnet and is restricted to Read, Grep, Glob</li>
      <li>The security-reviewer&rsquo;s findings reference OWASP categories from the preloaded skill</li>
      <li>The security-reviewer creates/updates <code>MEMORY.md</code> in <code>.claude/agent-memory/security-reviewer/</code></li>
      <li>Running the security-reviewer a second time shows it consulting memory from the first run</li>
      <li>You can monitor a headless agent via <code>tmux capture-pane</code> from a separate pane</li>
    </ul>

    <!-- WHAT'S NEXT -->
    <div class="callout success">
      <p><strong>What&rsquo;s Next:</strong> In <a href="course-09-skills-cli-integration.html">Course 9: CLI Integration</a>, you&rsquo;ll learn how to build skills that wrap CLI tools like <code>gh</code> and <code>git</code>, inject dynamic context from live CLI output, and create wrapper-command scripts that combine AI + CLI tools into standalone commands. You&rsquo;ll build a <code>github-release-notes</code> skill and a <code>dx-review.sh</code> wrapper script.</p>
    </div>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- PAGE NAVIGATION (Prev/Next) -->
    <nav class="page-nav">
      <a href="course-07h-terminal-workspace.html" class="prev">Terminal Workspace</a>
      <a href="course-09-skills-cli-integration.html" class="next">CLI Integration</a>
    </nav>

    <!-- BOTTOM SITE NAVIGATION (Phase-grouped) -->
    <nav class="site-nav-bottom">
      <h3>All Courses</h3>
      <ul>
        <!-- Phase 1: Skills Fundamentals -->
        <li class="nav-phase-label">Phase 1: Skills Fundamentals</li>
        <li><a href="course-01-first-skill.html">1. Your First Skill</a></li>
        <li><a href="course-02-descriptions-and-triggers.html">2. Descriptions &amp; Triggers</a></li>
        <li><a href="course-03-full-anatomy.html">3. Full Skill Anatomy</a></li>
        <li><a href="course-04-testing-iteration.html">4. Testing &amp; Iteration</a></li>
        <li><a href="course-05-advanced-features.html">5. Advanced Features</a></li>
        <li><a href="course-06-multi-step-workflows.html">6. Multi-Step Workflows</a></li>
        <li><a href="course-07-hooks.html">7. Hooks</a></li>

        <!-- Bridge -->
        <li class="nav-phase-label">Bridge</li>
        <li><a href="course-07h-terminal-workspace.html">7&frac12;. Terminal Workspace</a></li>

        <!-- Phase 2: Integrated Advanced -->
        <li class="nav-phase-label">Phase 2: Integrated Advanced</li>
        <li><a href="course-08-custom-subagents.html" class="current">8. Custom Subagents</a></li>
        <li><a href="course-09-skills-cli-integration.html">9. CLI Integration</a></li>
        <li><a href="course-10-agent-teams.html">10. Agent Teams</a></li>
        <li><a href="course-11-capstone.html">11. Capstone</a></li>
      </ul>
    </nav>

  </main>

  <footer>
    <p>Claude Code Skills &mdash; <a href="https://github.com/buildLittleWorlds/claude-code-skills-basics-and-beyond">GitHub Repository</a></p>
  </footer>

  <script src="copy-code.js"></script>

</body>
</html>
